(macro then do)
(macro else do)
(macro (!= a b)
       (not (= ,a ,b)))
(macro ([]+= lst idx val)
       (replace ,lst ,idx (+ (!! ,lst ,idx) ,val)))
(macro (!!- lst idx)
       (!! ,lst (- (length ,lst) ,idx)))
(macro (last-of lst)
       (!! ,lst "last"))
(macro (delete-last lst)
       (delete ,lst "last"))
(macro (replace-last lst val)
       (replace ,lst "last" ,val))
(macro (assert condition message)
       (real-assert ,condition ,message))
(macro (read idx)
       (!! heap ,idx))
(macro (write idx val)
       (replace heap ,idx ,val))
(macro CHAR-HEIGHT 12)
(macro CHAR-WIDTH 8)
(macro CHAR-SCALE 200)
(macro VEC-INITIAL-CAPACITY 2)
(macro (vec->size ptr)
       (+ 2 ,ptr))
(macro (vec.size ptr)
       (!! heap (+ 2 ,ptr)))
(macro (vec->at ptr i)
       (+ 2 ,ptr ,i))
(macro (vec.cap ptr)
       (- (!! heap ,ptr) 2))
(macro (dir->name ptr)
       (+ 2 ,ptr))
(macro (dir->parent ptr)
       (+ 3 ,ptr))
(macro (dir->content ptr)
       (+ 4 ,ptr))
(macro (block->type ptr)
       (+ 1 ,ptr))
(macro CHAR-NEWLINE "¦")
; # Memory layout
;
; ## File
; - Memory block size
; - "File"
; - Name of file
; - Pointer to parent directory
; - File content
;
; ## Directory
; - Memory block size
; - "Directory"
; - Name of directory
; - Pointer to parent directory
; - Pointer to vector of contained files
;
; ## Vec
; - Memory block size (capacity + 2)
; - Length of vector
; - Items...
(sprite "Stage"
  (costumes "backdrop" "assets/backdrop.png"))
(sprite "main"
(costumes "[unknown]" "assets/chars/unknown.png"
          " " "assets/chars/space.png"
          "A" "assets/chars/upper_a.png"
          "B" "assets/chars/upper_b.png"
          "C" "assets/chars/upper_c.png"
          "D" "assets/chars/upper_d.png"
          "E" "assets/chars/upper_e.png"
          "F" "assets/chars/upper_f.png"
          "G" "assets/chars/upper_g.png"
          "H" "assets/chars/upper_h.png"
          "I" "assets/chars/upper_i.png"
          "J" "assets/chars/upper_j.png"
          "K" "assets/chars/upper_k.png"
          "L" "assets/chars/upper_l.png"
          "M" "assets/chars/upper_m.png"
          "N" "assets/chars/upper_n.png"
          "O" "assets/chars/upper_o.png"
          "P" "assets/chars/upper_p.png"
          "Q" "assets/chars/upper_q.png"
          "R" "assets/chars/upper_r.png"
          "S" "assets/chars/upper_s.png"
          "T" "assets/chars/upper_t.png"
          "U" "assets/chars/upper_u.png"
          "V" "assets/chars/upper_v.png"
          "W" "assets/chars/upper_w.png"
          "X" "assets/chars/upper_x.png"
          "Y" "assets/chars/upper_y.png"
          "Z" "assets/chars/upper_z.png"
          "a" "assets/chars/lower_a.png"
          "b" "assets/chars/lower_b.png"
          "c" "assets/chars/lower_c.png"
          "d" "assets/chars/lower_d.png"
          "e" "assets/chars/lower_e.png"
          "f" "assets/chars/lower_f.png"
          "g" "assets/chars/lower_g.png"
          "h" "assets/chars/lower_h.png"
          "i" "assets/chars/lower_i.png"
          "j" "assets/chars/lower_j.png"
          "k" "assets/chars/lower_k.png"
          "l" "assets/chars/lower_l.png"
          "m" "assets/chars/lower_m.png"
          "n" "assets/chars/lower_n.png"
          "o" "assets/chars/lower_o.png"
          "p" "assets/chars/lower_p.png"
          "q" "assets/chars/lower_q.png"
          "r" "assets/chars/lower_r.png"
          "s" "assets/chars/lower_s.png"
          "t" "assets/chars/lower_t.png"
          "u" "assets/chars/lower_u.png"
          "v" "assets/chars/lower_v.png"
          "w" "assets/chars/lower_w.png"
          "x" "assets/chars/lower_x.png"
          "y" "assets/chars/lower_y.png"
          "z" "assets/chars/lower_z.png"
          "0" "assets/chars/zero.png"
          "1" "assets/chars/one.png"
          "2" "assets/chars/two.png"
          "3" "assets/chars/three.png"
          "4" "assets/chars/four.png"
          "5" "assets/chars/five.png"
          "6" "assets/chars/six.png"
          "7" "assets/chars/seven.png"
          "8" "assets/chars/eight.png"
          "9" "assets/chars/nine.png"
          "<" "assets/chars/less.png"
          ">" "assets/chars/greater.png"
          "-" "assets/chars/minus.png"
          "+" "assets/chars/plus.png"
          "∞" "assets/chars/infinity.png"
          "│" "assets/chars/boxdrawing_light_vertical.png"
          "─" "assets/chars/boxdrawing_light_horizontal.png"
          "┼" "assets/chars/boxdrawing_light_horizontal_and_vertical.png")
  (variables i
             j
             fs-root
             panic-message)
  (lists stack
         heap
         heap-refcounts)
  (proc (when-flag-clicked)
    (stack-init)
    (heap-init)
    (term-init)
    (create-fs-root)
    (create-directory "bin" fs-root)
    (create-directory "etc" fs-root)
    (heap-dump))
  (proc (term-init)
    (erase-all)
    (set-xy -232 172)
    (set-size CHAR-SCALE))
  ; Print a single character to the terminal.
  (proc (putchar char)
    (if (= char CHAR-NEWLINE)
      (then
        (linebreak))
      (else
        (set-costume "[unknown]")
        (set-costume char)
        (show)
        (stamp)
        (hide)
        (move-cursor-right))))
  ; Move the terminal cursor right by one characer, possibly switching to the
  ; next line.
  (proc (move-cursor-right)
    (if (< x-pos 228)
      (then
        (change-x CHAR-WIDTH))
      (else
        (linebreak))))
  ; Move the terminal cursor to the beginning of the next line.
  (proc (linebreak)
    (set-x -232)
    (change-y (- CHAR-HEIGHT)))
  ; Print a string to the terminal.
  (proc (print string)
    (for i (str-length string)
      (putchar (char-at string i))))
  ; Print a string to the terminal, followed by a new line.
  (proc (println string)
    (print (++ string CHAR-NEWLINE)))
  ; Make sure that a pointer points to the beginning of a valid memory block on
  ; the heap.
  (proc (validate-heap-ptr caller verb ptr)
    (:= panic-message (++ caller
                          ": Tried to "
                          verb
                          " index "
                          ptr))
    (assert (> ptr 0)
            (++ panic-message ", which is before the start of the heap"))
    (assert (not (> ptr (length heap)))
            (++ panic-message ", which is after the end of the heap"))
    (assert (!! heap-refcounts ptr)
            (++ panic-message ", which points to unallocated memory"))
    (assert (!= (!! heap-refcounts ptr) "Infinity")
            (++ panic-message ", which is in the middle of a memory block")))
  ; Terminate the program with a message.
  (proc (panic message)
    (:= panic-message message)
    (println (++ "Panic! " panic-message))
    (stop-all))
  ; Panic if a condition is not met.
  (proc (real-assert condition message)
    (unless (= condition "true")
      (panic message)))
  (proc (heap-f1 size)
    (for j (+ size 1)
      (unless (= 0 (!! heap-refcounts (+ i j -1)))
        (:= j -1)
        (stop-this-script))))
  ; Add a reference to a memory block.
  (proc (heap-share ptr)
    (validate-heap-ptr "heap-share" "share" ptr)
    ([]+= heap-refcounts ptr 1))
  ; Obtain a memory block on the heap with a given size. A pointer to the block
  ; gets pushed onto the stack.
  (proc (heap-allocate size)
    ; Look for an unallocated block that's big enough
    (for i (length heap)
      (heap-f1 size)
      (unless (= j -1)
        (append stack i)
        (write i size)
        (replace heap-refcounts i 1)
        (for j size
          (replace heap-refcounts (+ i j) "Infinity"))
        (stop-this-script)))
    ; No existing block found, grow the heap
    (append heap size)
    (append heap-refcounts 1)
    (append stack (length heap))
    (repeat size
      (append heap "")
      (append heap-refcounts "Infinity")))
  ; Decrease the reference count of a memory block and deallocate it if the
  ; count reaches 0. Custom destructors can be created by respondning to the
  ; message "_switch_heap_deallocate_X" where X is the type of the block being
  ; deallocated. When the message is received, a pointer to the block is
  ; available on the stack and should not be removed.
  (proc (heap-deallocate ptr)
    (validate-heap-ptr "heap-deallocate" "deallocate" ptr)
    ([]+= heap-refcounts ptr -1)
    (when (= (!! heap-refcounts ptr) 0)
      (append stack ptr)
      (send-broadcast-sync (++ "_switch_heap_deallocate_" (read (+ ptr 1))))
      (delete-last stack)
      (for i (read ptr)
        (write (+ ptr i) "")
        (replace heap-refcounts (+ ptr i) 0))
      (write ptr "")))
  (proc (heap-init)
    (delete-all heap)
    (delete-all heap-refcounts))
  (proc (stack-init)
    (delete-all stack))
  (proc (create-fs-root)
    (create-directory "root" 0)
    (:= fs-root (last-of stack))
    (delete-last stack))
  (proc (create-directory name parent)
    (heap-allocate 4)
    (write (block->type (last-of stack)) "Directory")
    (write (dir->name (last-of stack)) name)
    (write (dir->parent (last-of stack)) parent)
    (vec-new)
    (write (dir->content (!!- stack 1)) (last-of stack))
    (delete-last stack)
    (unless (= parent 0)
      (add-ptr-to-directory (last-of stack) parent)))
  (proc (add-ptr-to-directory ptr dir)
    (vec-push (dir->content dir) ptr))
  (proc (heap-dump)
    (println ">heap-dump")
    (println "Ptr │Value                                   │Refcount")
    (println "────┼────────────────────────────────────────┼────────")
    (for i (length heap)
      (rightpad i 4 " ")
      (rightpad (read i) 40 " ")
      (if (= (!! heap-refcounts i) "Infinity")
        (then
          (println (++ (!!- stack 1) "│" (last-of stack) "│∞")))
        (else
          (println (++ (!!- stack 1)
                       "│"
                       (last-of stack)
                       "│"
                       (!! heap-refcounts i)))))
      (delete-last stack)
      (delete-last stack)))
  ; Force a string to a certain width by truncating it or filling the remaining
  ; space to the right with a given character. The result gets pushed onto the
  ; stack.
  (proc (rightpad string width padding-char)
    (cond
      (< (str-length string) width)
      (then
        (append stack string)
        (repeat (- width (str-length string))
          (replace-last stack (++ (last-of stack) padding-char))))
      (= (str-length string) width)
      (then
        (append stack string))
      (else
        (append stack "")
        (for i (- width 1)
          (replace-last stack (++ (last-of stack) (char-at string i))))
        (replace-last stack (++ (last-of stack) "…")))))
  ; Resize a memory block. The new size must be at least as big as the old one.
  ; A pointer to the new block gets pushed onto the stack.
  (proc (heap-reallocate old-ptr new-size)
    (validate-heap-ptr "heap-reallocate" "move from" old-ptr)
    (assert (not (< new-size (read old-ptr)))
            "heap_reallocate: Tried to reallocate to a smaller memory block")
    (assert (< (!! heap-refcounts old-ptr) 2)
            "heap_reallocate: Tried to move from shared memory block")
    (heap-allocate new-size)
    (for i (read old-ptr)
      (write (+ (last-of stack) i) (read (+ old-ptr i))))
    (heap-deallocate old-ptr))
  ; Creates a new vector with the default capacity defined by
  ; `VEC-INITIAL-CAPACITY`. A pointer to the vector gets pushed onto the stack.
  (proc (vec-new)
    (vec-with-capacity VEC-INITIAL-CAPACITY))
  ; Like `vec-new` but it lets you choose an initial capacity.
  (proc (vec-with-capacity cap)
    (heap-allocate (+ 2 cap))
    (write (block->type (last-of stack)) "Vec")
    (write (vec->size (last-of stack)) 0))
  ; Append a value to a heap-allocated vector. The `vec` parameter is a pointer
  ; to a pointer to the vector so it can be changed in case of a reallocation.
  (proc (vec-push vec value)
    ; Reallocate if the vector is full
    (when (= (vec->size (read vec))
             (vec.cap (read vec)))
      (heap-reallocate (read vec) (+ 2 (* 2 (vec.size (read vec)))))
      (write vec (last-of stack))
      (delete-last stack))
    ([]+= heap (vec->size (read vec)) 1)
    (write
      (vec->at (read vec) (vec.size (read vec)))
      value)))
